---

---

<div id="stars-container"></div>
<div id="cursor-blackhole" class="cursor-blackhole"></div>

<style>
	.cursor-blackhole {
		position: fixed;
		width: 80px;
		height: 80px;
		border-radius: 50%;
		transform: translate(-50%, -50%);
		background: radial-gradient(
			circle at center,
			rgba(0, 0, 0, 1) 0%,
			rgba(0, 0, 0, 0.9) 25%,
			rgba(0, 0, 0, 0.8) 40%,
			rgba(0, 0, 0, 0.6) 60%,
			rgba(0, 0, 0, 0.3) 80%,
			transparent 100%
		);
		box-shadow: 0 0 40px 5px rgba(0, 0, 0, 0.8);
		pointer-events: none;
		z-index: 2;
		mix-blend-mode: multiply;
		filter: blur(2px);
		display: none;
	}

	@media (min-width: 768px) {
		.cursor-blackhole {
			display: block;
		}
		:global(body) {
			cursor: none;
		}
	}

	#stars-container {
		position: fixed;
		top: 0;
		left: 0;
		width: 100%;
		height: 100%;
		box-sizing: border-box;
		z-index: 1;
	}
</style>

<script>
	import { Application, Container, Graphics, Ticker } from 'pixi.js';

	window.addEventListener("DOMContentLoaded", async () => {
		const isMobile = window.innerWidth <= 767;
		const container = document.getElementById("stars-container");
		if (!container) {
			console.error('Container with id "stars-container" not found');
			return;
		}

		// Create PixiJS application
		const app = new Application();
		await app.init({
			width: window.innerWidth,
			height: window.innerHeight,
			backgroundColor: 0x000000,
			backgroundAlpha: 0,
			resizeTo: window,
		});

		// Add the application to the DOM
		container.appendChild(app.canvas);

		// Create containers for different layers
		const starsContainer = new Container();
		const meteorsContainer = new Container();
		app.stage.addChild(starsContainer);
		app.stage.addChild(meteorsContainer);

		// Star array
		let starArray = [];
		const starCount = Math.floor((window.innerWidth / 3840) * 1000);

		// Create star graphics texture for performance
		function createStarGraphics(size, opacity) {
			const star = new Graphics();
			
			// Create glow effect using multiple circles
			star.circle(0, 0, size * 1.5);
			star.fill({ color: 0xffffff, alpha: opacity * 0.1 });
			
			star.circle(0, 0, size);
			star.fill({ color: 0xffffff, alpha: opacity * 0.6 });
			
			star.circle(0, 0, size * 0.5);
			star.fill({ color: 0xffffff, alpha: opacity });

			return star;
		}

		// Initialize stars
		for (let i = 0; i < starCount; i++) {
			const x = Math.random() * window.innerWidth;
			const y = Math.random() * window.innerHeight;
			const size = 1.75 + Math.random() * 1.5;
			const angle = Math.random() * 2 * Math.PI;
			const speed = 0.1;
			const xVelocity = speed * Math.cos(angle);
			const yVelocity = speed * Math.sin(angle);
			const opacity = Math.random() * 0.7 + 0.3;
			const opacityChange = 0.01;
			const startTime = Date.now();
			const duration = Math.random() * 5000 + 5000;

			const starGraphics = createStarGraphics(size, opacity);
			starGraphics.x = x;
			starGraphics.y = y;
			starsContainer.addChild(starGraphics);

			starArray.push({
				graphics: starGraphics,
				x,
				y,
				size,
				xVelocity,
				yVelocity,
				opacity,
				opacityChange,
				startTime,
				duration,
				originalX: x,
				originalY: y,
				originalXVelocity: xVelocity,
				originalYVelocity: yVelocity,
			});
		}

		// Meteor array
		let meteorArray = [];

		// Create meteor graphics
		function createMeteorGraphics(size, opacity) {
			const meteor = new Graphics();
			meteor.circle(0, 0, size);
			meteor.fill({ color: 0xffffff, alpha: opacity });
			return meteor;
		}

		// Add meteors periodically
		setInterval(() => {
			if (meteorArray.length >= 3) {
				const oldMeteor = meteorArray.shift();
				meteorsContainer.removeChild(oldMeteor.graphics);
				oldMeteor.graphics.destroy();
			}

			const x = Math.random() * window.innerWidth;
			const y = Math.random() * window.innerHeight;
			const size = Math.random() * 30 + 30;
			const speed = Math.random() * 5 + 5;
			const angle = Math.PI / 4;
			const opacity = 0;
			const opacityChange = 0.04;

			const meteorGraphics = createMeteorGraphics(size, opacity);
			meteorGraphics.x = x;
			meteorGraphics.y = y;
			meteorsContainer.addChild(meteorGraphics);

			meteorArray.push({
				graphics: meteorGraphics,
				x,
				y,
				size,
				speed,
				angle,
				opacity,
				opacityChange,
			});
		}, 2000);

		if (isMobile) {
			// Mobile animation (simple)
			app.ticker.add(() => {
				const now = Date.now();

				starArray.forEach((star) => {
					const progress = ((now - star.startTime) % star.duration) / star.duration;
					const easedProgress = 1 - Math.pow(1 - progress, 3);

					// Update opacity (twinkling)
					star.opacity += star.opacityChange;
					if (star.opacity > 1) {
						star.opacity = 1;
						star.opacityChange = -star.opacityChange;
					} else if (star.opacity < 0.3) {
						star.opacity = 0.3;
						star.opacityChange = Math.abs(star.opacityChange);
					}

					// Update position
					star.x += star.xVelocity * easedProgress;
					star.y += star.yVelocity * easedProgress;

					// Wrap around edges
					if (star.x < 0) star.x = window.innerWidth;
					else if (star.x > window.innerWidth) star.x = 0;
					if (star.y < 0) star.y = window.innerHeight;
					else if (star.y > window.innerHeight) star.y = 0;

					// Update graphics
					star.graphics.x = star.x;
					star.graphics.y = star.y;
					star.graphics.alpha = star.opacity;
				});

				// Update meteors
				for (let i = meteorArray.length - 1; i >= 0; i--) {
					const meteor = meteorArray[i];
					meteor.x -= meteor.speed * Math.cos(meteor.angle);
					meteor.y += meteor.speed * Math.sin(meteor.angle);
					meteor.opacity += meteor.opacityChange;

					if (meteor.opacity > 1) {
						meteor.opacity = 1;
						meteor.opacityChange = -meteor.opacityChange;
					} else if (meteor.opacity < -0.1) {
						meteorsContainer.removeChild(meteor.graphics);
						meteor.graphics.destroy();
						meteorArray.splice(i, 1);
						continue;
					}

					meteor.graphics.x = meteor.x;
					meteor.graphics.y = meteor.y;
					meteor.graphics.alpha = Math.max(0, meteor.opacity);
				}
			});
		} else {
			// Desktop with black hole effects
			let targetX = 0;
			let targetY = 0;
			let blackholeX = 0;
			let blackholeY = 0;
			let currentX = 0;
			let currentY = 0;
			const INFLUENCE_RADIUS = 150;
			const GRAVITY_STRENGTH = 0.2;
			const RECOVERY_RATE = 0.02;
			const BLACK_HOLE_CORE_RADIUS = 20;

			// Mouse movement handler
			document.addEventListener("mousemove", (e) => {
				targetX = e.clientX;
				targetY = e.clientY;
				blackholeX = e.clientX;
				blackholeY = e.clientY;
			});

			app.ticker.add(() => {
				const now = Date.now();

				// Filter and update stars
				starArray = starArray.filter((star) => {
					const progress = ((now - star.startTime) % star.duration) / star.duration;
					const easedProgress = 1 - Math.pow(1 - progress, 3);

					const dx = blackholeX - star.x;
					const dy = blackholeY - star.y;
					const distance = Math.sqrt(dx * dx + dy * dy);

					// Check if star is consumed by black hole
					if (distance < BLACK_HOLE_CORE_RADIUS) {
						starsContainer.removeChild(star.graphics);
						star.graphics.destroy();
						return false;
					}

					if (distance < INFLUENCE_RADIUS) {
						// Apply gravitational pull
						const force = ((INFLUENCE_RADIUS - distance) / INFLUENCE_RADIUS) * GRAVITY_STRENGTH;
						const directionX = dx / (distance || 1);
						const directionY = dy / (distance || 1);

						star.xVelocity += directionX * force;
						star.yVelocity += directionY * force;

						// Add some randomness
						star.xVelocity += (Math.random() - 0.5) * 0.05;
						star.yVelocity += (Math.random() - 0.5) * 0.05;

						// Fade out as it gets closer
						star.opacity = Math.max(0.1, (distance - BLACK_HOLE_CORE_RADIUS) / INFLUENCE_RADIUS);
					} else {
						// Normal twinkling behavior
						star.opacity += star.opacityChange;
						if (star.opacity > 1) {
							star.opacity = 1;
							star.opacityChange = -star.opacityChange;
						} else if (star.opacity < 0.3) {
							star.opacity = 0.3;
							star.opacityChange = Math.abs(star.opacityChange);
						}

						// Return to original velocity
						star.xVelocity += (star.originalXVelocity - star.xVelocity) * RECOVERY_RATE;
						star.yVelocity += (star.originalYVelocity - star.yVelocity) * RECOVERY_RATE;
					}

					// Limit velocity
					const maxVelocity = 2;
					const currentVelocity = Math.sqrt(star.xVelocity * star.xVelocity + star.yVelocity * star.yVelocity);
					if (currentVelocity > maxVelocity) {
						star.xVelocity = (star.xVelocity / currentVelocity) * maxVelocity;
						star.yVelocity = (star.yVelocity / currentVelocity) * maxVelocity;
					}

					// Update position
					star.x += star.xVelocity * easedProgress;
					star.y += star.yVelocity * easedProgress;

					// Wrap around edges
					if (star.x < 0) star.x = window.innerWidth;
					else if (star.x > window.innerWidth) star.x = 0;
					if (star.y < 0) star.y = window.innerHeight;
					else if (star.y > window.innerHeight) star.y = 0;

					// Update graphics
					star.graphics.x = star.x;
					star.graphics.y = star.y;
					star.graphics.alpha = star.opacity;

					return true;
				});

				// Add new stars when needed
				while (starArray.length < (window.innerWidth / 3840) * 800) {
					const side = Math.floor(Math.random() * 4);
					let x, y;

					switch (side) {
						case 0: x = Math.random() * window.innerWidth; y = 0; break;
						case 1: x = window.innerWidth; y = Math.random() * window.innerHeight; break;
						case 2: x = Math.random() * window.innerWidth; y = window.innerHeight; break;
						case 3: x = 0; y = Math.random() * window.innerHeight; break;
					}

					const size = 1.75 + Math.random() * 1.5;
					const opacity = Math.random() * 0.7 + 0.3;
					const starGraphics = createStarGraphics(size, opacity);
					starGraphics.x = x;
					starGraphics.y = y;
					starsContainer.addChild(starGraphics);

					starArray.push({
						graphics: starGraphics,
						x,
						y,
						size,
						xVelocity: (Math.random() - 0.5) * 0.2,
						yVelocity: (Math.random() - 0.5) * 0.2,
						opacity,
						opacityChange: 0.01,
						startTime: now,
						duration: Math.random() * 5000 + 5000,
						originalX: x,
						originalY: y,
						originalXVelocity: (Math.random() - 0.5) * 0.2,
						originalYVelocity: (Math.random() - 0.5) * 0.2,
					});
				}

				// Update meteors
				for (let i = meteorArray.length - 1; i >= 0; i--) {
					const meteor = meteorArray[i];
					meteor.x -= meteor.speed * Math.cos(meteor.angle);
					meteor.y += meteor.speed * Math.sin(meteor.angle);
					meteor.opacity += meteor.opacityChange;

					if (meteor.opacity > 1) {
						meteor.opacity = 1;
						meteor.opacityChange = -meteor.opacityChange;
					} else if (meteor.opacity < -0.1) {
						meteorsContainer.removeChild(meteor.graphics);
						meteor.graphics.destroy();
						meteorArray.splice(i, 1);
						continue;
					}

					meteor.graphics.x = meteor.x;
					meteor.graphics.y = meteor.y;
					meteor.graphics.alpha = Math.max(0, meteor.opacity);
				}
			});

			// Black hole cursor animation
			const blackhole = document.getElementById("cursor-blackhole");
			if (blackhole) {
				function updatePosition() {
					const ease = 0.15;
					currentX += (targetX - currentX) * ease;
					currentY += (targetY - currentY) * ease;

					blackhole.style.left = `${currentX}px`;
					blackhole.style.top = `${currentY}px`;

					requestAnimationFrame(updatePosition);
				}
				updatePosition();
			}
		}

		// Handle window resize
		window.addEventListener('resize', () => {
			app.renderer.resize(window.innerWidth, window.innerHeight);
		});
	});
</script>